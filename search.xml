<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[BZOJ-1799]]></title>
    <url>%2F2018%2F09%2F05%2FBZOJ-1799%2F</url>
    <content type="text"><![CDATA[题目地址:点此传送题目Problem Description给出a,b，求出[a,b]中各位数字之和能整除原数的数的个数。 input无 Output无 Sample Input10 19 Sample Output3 HINT 【约束条件】$1\leq a\leq b\leq10^{18}$ 题意 看题(略) 思路 数位dp,我感觉很暴力,但是自己不会….dp[pos][sum][val],其中pos代表第几位,sum是剩下位数需要凑够的数,val是现在模mod后剩下的值,为什么说暴力呢? 这道题就是暴力枚举所以可能出现的位数和,也就是mod,每次换一个mod就得清一次dp(没办法dp没办法再开mod大了),所以我感觉还是有点暴力的…… 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const ll mod = 1e9 + 7;const int maxn = 1e4 + 10;ll dp[20][200][200];ll d[20];ll dfs(int pos,int sum,int val,int mod,int limit)&#123; if(sum-pos*9-9&gt;0) return 0; if(pos&lt;0) return sum==0&amp;&amp;val==0; if(sum&lt;0) return 0; if(!limit&amp;&amp;dp[pos][sum][val]!=-1) return dp[pos][sum][val]; ll ans=0; ll end=limit?d[pos]:9; for(int i=0;i&lt;=end;i++)&#123; if(sum-i&gt;=0)&#123; ans+=dfs(pos-1,sum-i,(val*10+i)%mod,mod,limit&amp;(i==end)); &#125; &#125; if(!limit) dp[pos][sum][val]=ans; return ans;&#125;ll solve(ll x)&#123; ll cnt=0; ll ans=0; while(x)&#123; d[cnt++]=x%10; x/=10; &#125; for(int i=1;i&lt;=cnt*9;i++)&#123; memset(dp,-1,sizeof(dp)); ans+=dfs(cnt-1,i,0,i,1); &#125; return ans;&#125;int main()&#123; ll a,b; scanf("%lld%lld",&amp;a,&amp;b); printf("%lld\n",solve(b)-solve(a-1)); return 0;&#125;]]></content>
      <categories>
        <category>ACM 简单dp</category>
      </categories>
      <tags>
        <tag>数位dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU-3709]]></title>
    <url>%2F2018%2F08%2F31%2FHDU-3709%2F</url>
    <content type="text"><![CDATA[题目地址:点此传送题目Problem DescriptionA balanced number is a non-negative integer that can be balanced if a pivot is placed at some digit. More specifically, imagine each digit as a box with weight indicated by the digit. When a pivot is placed at some digit of the number, the distance from a digit to the pivot is the offset between it and the pivot. Then the torques of left part and right part can be calculated. It is balanced if they are the same. A balanced number must be balanced with the pivot at some of its digits. For example, 4139 is a balanced number with pivot fixed at 3. The torqueses are $4\times2 + 1\times1 = 9\ and \ 9\times1 = 9$, for left part and right part, respectively. It’s your jobto calculate the number of balanced numbers in a given range [x, y]. InputThe input contains multiple test cases. The first line is the total number of cases T (0 &lt; T ≤ 30). For each case, there are two integers separated by a space in a line, x and y. (0 ≤ x ≤ y ≤ 1018). OutputFor each case, print the number of balanced numbers in the range [x, y] in a line. Sample Input20 97604 24324 Sample Output10897 题意 很简单,就是求[a,b]之间满足条件的数有多少个,条件举个例子来说(平衡数),例如4139 这个当中心是3时左边为$1\times1+4\times2=9$右边为$1\times9$,左边等于右边这算是一个平衡数,问你有多少这样的平衡数 思路 数位dp，dp[len][pos][sum] len代表第几位数字,pos代表以pos为中心,sum代表平衡数两边的的差，这道题可以遍历中心pos来进行数位dp,当len&lt;0且sum=0时代表是一个平衡数,sum可以用一种方法表示,到pos的距离乘以的d[i](第i位) 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;bits/stdc++.h&gt;#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;#define ll long long#define rd(a) scanf("%d",&amp;a)#define rld(a) scanf("%lld",&amp;a)#define rs(a) scanf("%s",a)#define me(a,b) memset(a,b,sizeof(a))#define pb(a) push_back(a)const ll maxn=3e5+10;const ll mod =1e9+7;const ll inf =0x3f3f3f3f;const double PI=acos(-1);int d[20];ll dp[20][20][2000];ll dfs(int len,int pos,int limit,int sum)&#123; if(len&lt;0) return sum==0; if(sum&lt;0) return 0; if(!limit&amp;&amp;dp[len][pos][sum]!=-1) return dp[len][pos][sum]; int end=limit?d[len]:9; ll ans=0; for(int i=0;i&lt;=end;i++)&#123; ans+=dfs(len-1,pos,limit&amp;(i==end),sum+i*(len-pos)); &#125; if(!limit) dp[len][pos][sum]=ans; return ans; &#125;ll solve(ll x)&#123; int len=0; while(x)&#123; d[len++]=x%10; x/=10; &#125; ll ans=0; for(int i=0;i&lt;len;i++) ans+=dfs(len-1,i,1,0); return ans-len+1;&#125;int main()&#123; me(dp,-1); int t; rd(t); while(t--)&#123; ll a,b; rld(a),rld(b); printf("%lld\n",solve(b)-solve(a-1)); &#125; return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[hexo 博客搭建与next 6.0主题配置]]></title>
    <url>%2F2018%2F08%2F14%2Fhexo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E4%B8%8Enext-6-0%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[请输入密码！！ Incorrect Password! No content to display! U2FsdGVkX19nft0XVCpIQVzJtDcpxlG8zxICt025S5/CWJS1MC3cYp1eSg0G8hT6tAiOyjK2Ktn33yfiymwN7M8wz+t5JX5XrDZ3ttj+rd30U/hCcO5D8bThoof31aQav7dEPoDG/hcT8OIak+15CPVoO2ULy3Tbv+kWsaowmfd1mx7M6nlOPWyFtXhdF109nWmjHEuWFN+4pl4OhQCEV0Ls0SOjOP9No2ntnTwPPsQ+UjLul7jhrR7eh2CUQNV2YaALGDhlHZcCP9awgMFY/oGKOTMcUCdh0p6DVSmdnMCZjcVXDf50p07Vqq/VUuQCELXeIIs7xQCz0VBN/bSO+0xD3FSuuYqLUDk+SGz8kDU6uwDAXv3f/V5CRTbaVvNG/VnHB6LHtidjq9Kd2j5p0QobiTOna/UF5CAwF8583ILkWbcY+Y8zfyOwL96SxBtWBSz2Ru1YLM5goPGO9Uzc2vb1qYb11U4Z6mPjvArANQJR0Ws6z0fljTk4WT8rtc6j5R+YmO0YtFCh7tneW0o0m3d7ZmvZ9OgJGi+pZFnv1CIlClfs4XJpT8O2xkwa3VGTiJg3OfBVgqlTQhdMg1/h7ZrNkwvnZIv+DQSoV1VXfjpEsZv3ylhY8lf6aFuH2PIVEHq67+pYpzyRzyfN8lm1rTrV2ggnMyX3JalFg/LLvg/t6f/PQx+XUodglajZo/yEODp2Ig6E1qv8fjxmeaOLR8xdT7uHiCc0UJ5LisLWOB0CF5cIz1hy8A+BCMaJNtsJxBO+SVcDV8kRBM8otvdoRw==]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
