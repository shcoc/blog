<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[LCA(总结+模板)]]></title>
    <url>%2F2018%2F09%2F07%2FLCA-%E6%80%BB%E7%BB%93-%E6%A8%A1%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[LCA介绍LCA即最近公共祖先问题,求一棵树上两个点的最近祖先。 LCA有两种类型的算法,离线算法和在线算法 离线算法 Tarjan算法 在线算法 倍增算法 LCA转化RMQLCA算法介绍 Tarjan算法 Tarjan算法是离线算法,时间复杂度$O(n+q)$,主要是dfs和并查集 先来个树 这个算法主要就是dfs搜索时每次都行搜子树,然后用并查集把子节点跟父节点连到一起,因为是深搜(假设搜a-b) 查询两个点在同一支上,那么在上面的点就是最近祖先,在搜到子树点时都会用并查集跟父节点压缩到一块,直到最后到的点(a),最后查询到find(b)(假设a在上)而find(b)因为路上的节点压缩等于a 查询的两个点不在同一支上,那么最近祖先就是这个子树的根节点,和1一样(假设先搜到b)它也是一直压缩到它的父节点在换右支时,find(b)就是这颗子树的根节点,最后查询到find(b)(假设a在上)而find(b)因为路上的节点压缩等于a 在说一个例子吧. 假设看这个图中的一颗小树 8 4 6 15 7 然后查 15-7 15-4 7-4 ,我们来模拟一下,直接搜到最底层 15 没有子树,把15和他的父节点连到一块,标记15号点,然后找所有与15有关的查询 ,有两个15-7 15-4,然后发现4 7都没有标记,不处理回退到6 ,然后进到7,和15一样操作,在查找与7相关的查询是发现15已经标记过了,这时候find(15)就是 15-7的最近祖先,其他点也类似 代码(模板) 1待补充 倍增算法 一种很神奇的算法,与RMQ原理相似,都是利用打表,时间复杂度$O((n+q)logn)$ 同样先来个树 倍增,一种好的思想,可惜我还是不懂qaq ,这个原理容易懂,先跑出来距离每个点距离为1的祖先节点,这个很容易找,就是一遍dfs的事,然后利用倍增的思想,递推出所有距离该节点二的次方的所有节点,例如f[i][j]=f[f[i][j-1]][j-1] (i代表节点 j代表距离$2^j$ ,就是距离一个节点$2^n$等于距离&lt;距离这个节点$2^{n-1}$的节点&gt;的节点$2^{n-1}$的节点),这个算法就是在你打完所有距离每一个节点2的次幂距离的点的表后,去处理 先把两个节点调到一个高度,把一个节点往上移动 a=f[a][j],移动多少呢,因为我们存下的都是二的倍数,所以你会想到二进制,直接把两个数高度差的二进制移动 到同一高度后,同时往上移动,一个一个移动肯定很慢啊,怎么办呢还是利用二进制啊,倍增好像就是这样,用二的次幂处理,我们可以倒着尝试移动,从直接移动log2(n)(why? log2(n)就是移动$2^{log_2(n)}$次肯定会移动到最上面滴)如果相等,那就是在移动$2^{log_2(n)}$之前就有可能找到一个相同点,那么这个就不移动,继续找,最后这个点的父节点就是最近公共祖先 例子就没必要了,自己推吧 代码 1待补充 LCA 转化成RMQRMQ 算法介绍 就是求一段数列的最大值,和最小值 预处理$nlog(n)$ 查询 $O(1)$ 未完待续 9.18]]></content>
      <tags>
        <tag>ACM模板</tag>
        <tag>ACM总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU-4507]]></title>
    <url>%2F2018%2F09%2F06%2FHDU-4507%2F</url>
    <content type="text"><![CDATA[题目地址:点此传送题目Problem Description单身! 依然单身！ 吉哥依然单身！ DS级码农吉哥依然单身！ 所以，他生平最恨情人节，不管是214还是77，他都讨厌！ 吉哥观察了214和77这两个数，发现： $2+1+4=7$ $7+7=7\times 2 $ $77=7\times 11$ 最终，他发现原来这一切归根到底都是因为和7有关！所以，他现在甚至讨厌一切和7有关的数！ 什么样的数和7有关呢？ 如果一个整数符合下面3个条件之一，那么我们就说这个整数和7有关—— 1、整数中某一位是7； 2、整数的每一位加起来的和是7的整数倍； 3、这个整数是7的整数倍； 现在问题来了：吉哥想知道在一定区间内和7无关的数字的平方和。 input 输入数据的第一行是case数T(1 &lt;= T &lt;= 50)，然后接下来的T行表示T个case;每个case在一行内包含两个正整数L, R(1 &lt;= L &lt;= R &lt;= 10^18)。 Output 请计算[L,R]中和7无关的数字的平方和，并将结果对10^9 + 7 求模后输出。 Sample Input31 910 1117 17 Sample Output2362210 HINT 2013腾讯编程马拉松初赛第一场（3月21日） 题意 看题(略) 思路 数位dp,以前只做过记录个数的没做过记录和,第一眼我把记录的个数改成平方和,一直t也不知道咋回事……后来搜的题解,还是利用求个数,就是多记录了两个数$c^2=(a+b)^2=a^2+2\times b+b^2$假设找到第i个位置时,搜索数的大小为 $i\times pow(i,pos)$,这个位置之后的数字为num1,num2,num3 …. numN,则 i位以后所有满足数的平方和为$=((i\times pow(i,pos)+num1)^2+(i\times pow(i,pos)+num2)^2 +$$(i\times pow(i,pos)+num3)^2+\dots +(i\times pow(i,pos)+numN)^2)$$ =N\times (i\times pow(i,pos)^2)^2+2\times i\times pow(i,pos)\times (num1+num2+num3$$+\dots+numN)+(num1^2+num2^2+num3^2+\dots +numN^2)$ 所以我们只需维护满足的个数 n ,num的和,$num^2$就行开个结构体dp[pos][num][sum].c 代表次数 dp[pos][num][sum].sum 代表num和 dp[pos][num][sum].sqsum 平方和 (其他 pos 第几位,num数字,sum每一位位和)dp很巧妙,具体看代码 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const ll mod=1e9+7;void read(ll &amp;x)&#123; int f=1;x=0;char s=getchar(); while(s&lt;'0'||s&gt;'9')&#123;if(s=='-')f=-1;s=getchar();&#125; while(s&gt;='0'&amp;&amp;s&lt;='9')&#123;x=x*10+s-'0';s=getchar();&#125; x*=f;&#125;struct ss&#123; ll c; ll sum; ll sqsum;&#125;dp[20][10][10];int d[20];ss dfs(int pos,int num,int sum,int limit)&#123; if(!limit&amp;&amp;dp[pos][num][sum].c!=-1) return dp[pos][num][sum]; int end=limit?d[pos]:9; ll p=pow(10LL,pos); ss ans; ans.c=ans.sum=ans.sqsum=0; for(int i=0;i&lt;=end;i++)&#123; if(i==7) continue; if(pos==0) &#123;if((sum+i)%7&amp;&amp;(i+num)%7) &#123; ans.c++;ans.sum+=i;ans.sqsum+=i*i;&#125;&#125; else &#123; //p pow(10,pos) 变为该位置数的大小 ss k=dfs(pos-1,(num+i*p)%7,(sum+i)%7,limit&amp;(i==end)); ans.c=(ans.c+k.c)%mod; //次数 等于他后面的所有次数和 ll q1=(i*p)%mod; //上面推导的 i*pow(10,pos) ll q2=(q1*q1)%mod; // (i*pow(10,pos))^2 ans.sum=(ans.sum+k.sum+k.c*q1)%mod; //每个数都有增加个 i*pow(10,pos)所以一共增加 k.c*q1 再加上原来的 ans.sqsum=(ans.sqsum+(k.c*q2%mod)+((k.sum*q1%mod)*2)%mod+k.sqsum)%mod; //利用上面推导 &#125; &#125; if(!limit)&#123; dp[pos][num][sum].c=ans.c; dp[pos][num][sum].sum=ans.sum; dp[pos][num][sum].sqsum=ans.sqsum; &#125; return ans;&#125;ll solve(ll x)&#123; if(x==0) return x; int cnt=0; while(x)&#123;d[cnt++]=x%10;x/=10;&#125; return dfs(cnt-1,0,0,1).sqsum%mod;&#125;int main()&#123; for(int i=0;i&lt;20;i++) for(int j=0;j&lt;10;j++) for(int k=0;k&lt;10;k++) dp[i][j][k].c=dp[i][j][k].sum=dp[i][j][k].sqsum=-1; ll a,b; int t; scanf("%d",&amp;t); while(t--)&#123; scanf("%lld%lld",&amp;a,&amp;b); printf("%lld\n",(solve(b)-solve(a-1)+mod)%mod); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ-1799]]></title>
    <url>%2F2018%2F09%2F05%2FBZOJ-1799%2F</url>
    <content type="text"><![CDATA[题目地址:点此传送题目Problem Description给出a,b，求出[a,b]中各位数字之和能整除原数的数的个数。 input无 Output无 Sample Input10 19 Sample Output3 HINT 【约束条件】$1\leq a\leq b\leq10^{18}$ 题意 看题(略) 思路 数位dp,我感觉很暴力,但是自己不会….dp[pos][sum][val],其中pos代表第几位,sum是剩下位数需要凑够的数,val是现在模mod后剩下的值,为什么说暴力呢? 这道题就是暴力枚举所以可能出现的位数和,也就是mod,每次换一个mod就得清一次dp(没办法dp没办法再开mod大了),所以我感觉还是有点暴力的…… 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const ll mod = 1e9 + 7;const int maxn = 1e4 + 10;ll dp[20][200][200];ll d[20];ll dfs(int pos,int sum,int val,int mod,int limit)&#123; if(sum-pos*9-9&gt;0) return 0; if(pos&lt;0) return sum==0&amp;&amp;val==0; if(sum&lt;0) return 0; if(!limit&amp;&amp;dp[pos][sum][val]!=-1) return dp[pos][sum][val]; ll ans=0; ll end=limit?d[pos]:9; for(int i=0;i&lt;=end;i++)&#123; if(sum-i&gt;=0)&#123; ans+=dfs(pos-1,sum-i,(val*10+i)%mod,mod,limit&amp;(i==end)); &#125; &#125; if(!limit) dp[pos][sum][val]=ans; return ans;&#125;ll solve(ll x)&#123; ll cnt=0; ll ans=0; while(x)&#123; d[cnt++]=x%10; x/=10; &#125; for(int i=1;i&lt;=cnt*9;i++)&#123; memset(dp,-1,sizeof(dp)); ans+=dfs(cnt-1,i,0,i,1); &#125; return ans;&#125;int main()&#123; ll a,b; scanf("%lld%lld",&amp;a,&amp;b); printf("%lld\n",solve(b)-solve(a-1)); return 0;&#125;]]></content>
      <categories>
        <category>ACM 简单dp</category>
      </categories>
      <tags>
        <tag>数位dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU-3709]]></title>
    <url>%2F2018%2F08%2F31%2FHDU-3709%2F</url>
    <content type="text"><![CDATA[题目地址:点此传送题目Problem DescriptionA balanced number is a non-negative integer that can be balanced if a pivot is placed at some digit. More specifically, imagine each digit as a box with weight indicated by the digit. When a pivot is placed at some digit of the number, the distance from a digit to the pivot is the offset between it and the pivot. Then the torques of left part and right part can be calculated. It is balanced if they are the same. A balanced number must be balanced with the pivot at some of its digits. For example, 4139 is a balanced number with pivot fixed at 3. The torqueses are $4\times2 + 1\times1 = 9\ and \ 9\times1 = 9$, for left part and right part, respectively. It’s your jobto calculate the number of balanced numbers in a given range [x, y]. InputThe input contains multiple test cases. The first line is the total number of cases T (0 &lt; T ≤ 30). For each case, there are two integers separated by a space in a line, x and y. (0 ≤ x ≤ y ≤ 1018). OutputFor each case, print the number of balanced numbers in the range [x, y] in a line. Sample Input20 97604 24324 Sample Output10897 题意 很简单,就是求[a,b]之间满足条件的数有多少个,条件举个例子来说(平衡数),例如4139 这个当中心是3时左边为$1\times1+4\times2=9$右边为$1\times9$,左边等于右边这算是一个平衡数,问你有多少这样的平衡数 思路 数位dp，dp[len][pos][sum] len代表第几位数字,pos代表以pos为中心,sum代表平衡数两边的的差，这道题可以遍历中心pos来进行数位dp,当len&lt;0且sum=0时代表是一个平衡数,sum可以用一种方法表示,到pos的距离乘以的d[i](第i位) 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;bits/stdc++.h&gt;#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;#define ll long long#define rd(a) scanf("%d",&amp;a)#define rld(a) scanf("%lld",&amp;a)#define rs(a) scanf("%s",a)#define me(a,b) memset(a,b,sizeof(a))#define pb(a) push_back(a)const ll maxn=3e5+10;const ll mod =1e9+7;const ll inf =0x3f3f3f3f;const double PI=acos(-1);int d[20];ll dp[20][20][2000];ll dfs(int len,int pos,int limit,int sum)&#123; if(len&lt;0) return sum==0; if(sum&lt;0) return 0; if(!limit&amp;&amp;dp[len][pos][sum]!=-1) return dp[len][pos][sum]; int end=limit?d[len]:9; ll ans=0; for(int i=0;i&lt;=end;i++)&#123; ans+=dfs(len-1,pos,limit&amp;(i==end),sum+i*(len-pos)); &#125; if(!limit) dp[len][pos][sum]=ans; return ans; &#125;ll solve(ll x)&#123; int len=0; while(x)&#123; d[len++]=x%10; x/=10; &#125; ll ans=0; for(int i=0;i&lt;len;i++) ans+=dfs(len-1,i,1,0); return ans-len+1;&#125;int main()&#123; me(dp,-1); int t; rd(t); while(t--)&#123; ll a,b; rld(a),rld(b); printf("%lld\n",solve(b)-solve(a-1)); &#125; return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[hexo 博客搭建与next 6.0主题配置]]></title>
    <url>%2F2018%2F08%2F14%2Fhexo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E4%B8%8Enext-6-0%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[请输入密码！！ Incorrect Password! No content to display! U2FsdGVkX19G+I3ymjcWtnzoCZOMwXTV0D5VLcD1DbdRh1m+XwZthgxaiE/XGNqeK2j5OHUyzeB55WbUZr1/JVV4uVtxenSHJemUI/gKHAEEYcST+Ji7GjRC3QCzjmjBpbINpHOlMT+Ok/BzNtUyPWfOauvtuBTMCOhLXbieaKxk2NU3H69V7JT2/QP7/+01Lxx89pE1awWgbM0oLouM/z+Ch/ol0k9NcAXj3tR4yO1Zc0y1P4PPfNzKeqBLr2iIKVDoIRb6YltrOa8OLNIigQ+pFFGymbGtTZ87SvR6vwpWsE6UwVxaGUohCOs+uGZr2Y5DBDy8DO96Xe/AvIh/UoD8Q/vcaQsz8GbRcSY/g/x3khPPQ3ThfQoQGNoX69+unEpHF13wEK1NybHQKOVWD+xC7H6kj2wS8e49+UmyuB3QdVRW1siZOyTSLj2lxR2wNc6E4RnD5RJnilLYti2A6Y3VzqBu2ZtoUwtV/FKC2Vm0lG7x368G7d4qpH+hI/8kR7kw6tHtYu0XcK2vaGOWQNgerAUjMTdLd2e+WpxzUKpxk2ZNRauqtAtYcVTjI+lsI7F9qHpl24Jj+oZNiywZB5Gv77VFvp8P2Wip07txfL3hLH9T2D+B1zx5tb+Oyxc13Eba1Qa2Ir/FbiBXd7DYr4xd1f77HvirKtX9A/LC4CEDz/PRNhi4hiyJok0VCbPKrSyiQdBR9ZktDKlSayaibaozxw3Mu4wUUtq35lLYCKs9+ZUeqZY513fNdY26IVrQNVP29KMDquzMGwrO3dCxrA==]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
